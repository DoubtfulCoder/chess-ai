{"version":3,"file":"static/js/470.c3966489.chunk.js","mappings":"8HAGMA,G,cAAU,CACfC,EAAG,CAAEA,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDJ,EAAG,CAAED,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDH,EAAG,CAAEF,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDF,EAAG,CAAEH,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDD,EAAG,CAAEJ,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDA,EAAG,CAAEL,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,OAI3CC,EAAc,CAGnBN,EAAG,CACF,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAC9B,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAC1C,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAIrCC,EAAG,CACF,CAAC,GAAK,GAAK,EAAK,EAAK,EAAK,GAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,EAAE,GAAI,GAAK,GAAK,EAAK,EAAK,GAAK,IAAK,IACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAGrCC,EAAG,CACF,CAAC,EAAK,GAAK,GAAK,EAAK,GAAK,GAAK,EAAK,GACpC,CAAC,EAAK,GAAK,EAAK,GAAK,GAAK,EAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,GAAK,EAAK,EAAK,GAAK,EAAK,GACpC,CAAC,EAAK,GAAK,EAAK,EAAK,EAAK,EAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAErCC,EAAG,CACF,CAAC,EAAK,EAAK,GAAK,GAAK,GAAK,GAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAErCC,EAAG,CACF,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAErCC,EAAG,CACF,CAAC,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,GAAK,IAAK,GAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,KAKhCE,EAAiB,CAGtBP,EAAG,CACF,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAC9B,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAC1C,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAIrCC,EAAG,CACF,CAAC,GAAK,GAAK,EAAK,EAAK,EAAK,GAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,EAAE,GAAI,GAAK,GAAK,EAAK,EAAK,GAAK,IAAK,IACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAGrCC,EAAG,CACF,CAAC,EAAK,GAAK,GAAK,EAAK,GAAK,GAAK,EAAK,GACpC,CAAC,EAAK,GAAK,EAAK,GAAK,GAAK,EAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,GAAK,EAAK,EAAK,GAAK,EAAK,GACpC,CAAC,EAAK,GAAK,EAAK,EAAK,EAAK,EAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAErCC,EAAG,CACF,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAErCC,EAAG,CACF,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAGrCC,EAAG,CACF,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,GAAK,EAAK,GACpC,CAAC,EAAK,GAAK,G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","sources":["PositionEval.js","App.js","worker.js"],"sourcesContent":["import { isQuietMove, pieceValues } from \"./App\";\n\n// Access using MVV_LVA[Victim][Attacker]\nconst MVV_LVA = {\n\tp: { p: 105, n: 104, b: 103, r: 102, q: 101, k: 100 },\n\tn: { p: 205, n: 204, b: 203, r: 202, q: 201, k: 200 },\n\tb: { p: 305, n: 304, b: 303, r: 302, q: 301, k: 300 },\n\tr: { p: 405, n: 404, b: 403, r: 402, q: 401, k: 400 },\n\tq: { p: 505, n: 504, b: 503, r: 502, q: 501, k: 500 },\n\tk: { p: 605, n: 604, b: 603, r: 602, q: 601, k: 600 },\n};\n\n// Best squares for different pieces to be on (black's perspective) \nconst bestSquares = {\n\t// pawns usually better in center\n\t// prettier-ignore\n\tp: [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.3, 0.2, 0.2, 0.3, 0.3, 0.1, 0.3, 0.3],\n\t\t[0.2, 0.1, 0.4, 0.5, 0.5, 0.1, 0.1, 0.1],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// knights better towards center not edges\n\t// prettier-ignore\n\tn: [\n\t\t[0.0,-0.1, 0.0, 0.0, 0.0, 0.0,-0.1, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0],\n\t\t[-0.1,0.2, 0.4, 0.0, 0.0, 0.4, 0.2,-0.1],\n\t\t[0.0, 0.0, 0.0, 0.3, 0.3, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// prettier-ignore\n\tb: [\n\t\t[0.0, 0.0,-0.1, 0.0, 0.0,-0.1, 0.0, 0.0],\n\t\t[0.0, 0.3, 0.0, 0.1, 0.1, 0.0, 0.3, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.3, 0.0, 0.0, 0.3, 0.0, 0.0],\n\t\t[0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\tr: [\n\t\t[0.0, 0.0, 0.2, 0.3, 0.3, 0.2, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\tq: [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\tk: [\n\t\t[0.0, 0.0, 0.0,-0.5, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0,-0.5,-0.5, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t]\n};\n\n// Best squares for endgame (start pushing pawns, rooks, king)\nconst endgameSquares = {\n\t// pawns usually better in center\n\t// prettier-ignore\n\tp: [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2],\n\t\t[0.3, 0.3, 0.3, 0.5, 0.5, 0.3, 0.3, 0.3],\n\t\t[0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],\n\t\t[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n\t\t[0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// knights better towards center not edges\n\t// prettier-ignore\n\tn: [\n\t\t[0.0,-0.1, 0.0, 0.0, 0.0, 0.0,-0.1, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.1, 0.1, 0.0, 0.0, 0.0],\n\t\t[-0.1,0.1, 0.1, 0.0, 0.0, 0.1, 0.1,-0.1],\n\t\t[0.0, 0.0, 0.0, 0.1, 0.1, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// prettier-ignore\n\tb: [\n\t\t[0.0, 0.0,-0.1, 0.0, 0.0,-0.1, 0.0, 0.0],\n\t\t[0.0, 0.1, 0.0, 0.1, 0.1, 0.0, 0.1, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.1, 0.1, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.1, 0.0, 0.0, 0.1, 0.0, 0.0],\n\t\t[0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\tr: [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\tq: [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// prettier-ignore\n\tk: [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0, 0.0],\n\t\t[0.0, 0.2, 0.2, 0.2, 0.2, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.2, 0.2, 0.2, 0.2, 0.2, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.2, 0.2, 0.2, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n};\n\n// strip off any move decorations: e.g Nf3+?! becomes Nf3\nfunction stripped_san(move) {\n\t//   return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n\treturn move.replace(/[+#]?[?!]*$/, '');\n}\n\n// gets move in SAN (e.g. Nc4) and gets corresponding eval from bestSquares/endgameSquares\nexport function moveEval(move, color='black', numPiecesOnBoard) {\n\tlet moveValue = 0;\n    // castling is +0.7\n    if (move.includes('O-O')) { return 0.7; }\n    // promotion is +9\n    if (move.includes('=')) { return 9; }\n    // discourage checks in beginning(?)\n    if (move.includes('+') && numPiecesOnBoard > 20) { moveValue += -0.3; }\n\t// encourage captures slightly\n\tif (move.includes('x')) { moveValue += 0.3; }\n\n    move = stripped_san(move); // remove decorations like +!?# at end\n\t// piece code is always first char for non-pawns\n\tlet piece = move[0];\n\t// pawn moves are like 'd4' or 'bxc4' without 'P' char\n\tif (piece !== 'B' && piece !== 'N' && piece !== 'R' && piece !== 'Q' && piece !== 'K') {\n        piece = 'p';\n    }\n    piece = piece.toLowerCase();\n\tconst square = move.slice(move.length - 2, move.length); // square is always last two chars\n\n\t// convert characters to numbers\n    let rank;\n    let file;\n    if (color === 'white') {\n        rank = square.charCodeAt(0) - 97;\n        file = square.charCodeAt(1) - 49;\n    } else {\n        rank = square.charCodeAt(0) - 97;\n        file = 7 - (square.charCodeAt(1) - 49);\n    }\n\n\t// check for endgame (<= 15 pieces)\n\tif (numPiecesOnBoard <= 15) {\n\t\tconsole.log('endgame!');\n\t\treturn endgameSquares[piece][rank][file] + moveValue;\n\t} \n\t\n\treturn bestSquares[piece][file][rank] + moveValue;\n}\n\n/* Gets the value of a capture using MVV-LVA table */\nexport function getCaptureValue(game, move) {\n\tmove = stripped_san(move); // remove decorations like +!?# at end\n\tlet value = 0;\n\t// check for promotion\n\tif (move.includes('=')) {\n\t\t// add promoted piece's value\n\t\tvalue += pieceValues[move[move.length - 1].toLowerCase()];\n\t\tmove = move.slice(0, move.length - 2); // remove promotion piece\n\t}\n\n\t// piece code is always first char for non-pawns\n\tlet attacker = move[0];\n\tif (attacker !== 'B' && attacker !== 'N' && attacker !== 'R' && attacker !== 'Q' && attacker !== 'K') {\n        attacker = 'p';\n    }\n    attacker = attacker.toLowerCase();\n\t\n\t// last two chars are victim square\n\t// TOOD : check en pessant\n\tconst victimSquare = move.slice(move.length - 2, move.length);\n\tconst victim = game.get(victimSquare).type.toLowerCase();\n\n\tvalue += MVV_LVA[victim][attacker]\n\treturn value;\n}\n\n/* Get value of move (captures given higher value) */\nexport function getMoveValue(game, move) {\n\tif (isQuietMove(game, move)) {\n\t\treturn 0;\n\t} else {\n\t\ttry {\n\t\t\treturn getCaptureValue(game, move);\n\t\t} catch(e) { // doesn't work on en pessant yet\n\t\t\t// console.error(e);\n\t\t\t// console.log(move);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n}\n\nfunction getMoveValueTEST(game, move) {\n\treturn 0;\n}\n\n/* Sorts moves in descending order by capture value */\nexport function sortMoves(game, moves) {\n\t// return moves.sort((a, b) => {\n\t// \treturn getMoveValue(game, b) - getMoveValue(game, a);\n\t// });\n\n    let moveScores = [];\n    \n    // score all moves \n    for (let i = 0; i < moves.length; i++) {\n        moveScores[i] = getMoveValue(game, moves[i]);\n\t}\n    \n    // loop over current move within a move list\n    for (let current_move = 0; current_move < moves.length; current_move++)\n    {\n        // loop over next move within a move list\n        for (let next_move = current_move + 1; next_move < moves.length; next_move++)\n        {\n            // compare current and next move scores\n            if (moveScores[current_move] < moveScores[next_move])\n            {\n                // swap scores\n                let temp_score = moveScores[current_move];\n                moveScores[current_move] = moveScores[next_move];\n                moveScores[next_move] = temp_score;\n                \n                // swap moves\n                let temp_move = moves[current_move];\n                moves[current_move] = moves[next_move];\n                moves[next_move] = temp_move;\n            }\n        }\n    }\n\n\t// console.log('moveScores', moveScores);\n\n\treturn moves;\n}\n\n// TODO : code below may help with from square \n// function getEval(move) {\n//     const san = move.san;\n//     const piece = san[0];\n//     const from = san.slice(1, 3);\n//     const to = san.slice(3, 5);\n//     const fromSquare = chess.square(from);\n//     const toSquare = chess.square(to);\n//     const pieceEval = bestSquares[piece][toSquare];\n//     return pieceEval;\n// }","import { Chess } from 'chess.js';\nimport { useRef, useState } from 'react';\nimport { Chessboard } from 'react-chessboard';\nimport { moveEval, sortMoves } from './PositionEval';\n\n// console.log('Qd6', moveEval('Qd6', 'black'));\nconsole.log('Number of threads on your device: ', navigator.hardwareConcurrency);\n\n// Gets number of threads on your device\nconst NUM_THREADS = navigator.hardwareConcurrency - 1;\n\n// Position constants\nconst QUEENS_RAID = 'rnb1k1nr/pppp1ppp/5q2/2b1p3/4P1Q1/2N5/PPPP1PPP/R1B1KBNR w KQkq - 4 4';\nconst MATE_IN_ONE = 'k7/4Q3/5R2/p7/4P3/2N5/PPPPBPPP/R1B1K1N1 w Q - 0 1';\nconst TRICKY_POSITION = 'r3k2r/p1ppqpb1/bn2pnp1/3PN3/4P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1';\nconst ENDGAME_POSITION = '6k1/p3n1p1/1p3rp1/2p1p3/P1Pp1P2/1P1P4/3KPR2/6R1 w - - 0 34';\nconst ENDGAME_POSITION_2 = '1r6/1P1kn3/3bppp1/7p/5N1P/6P1/3B1P2/1R4K1 w - - 0 1';\nconst FREE_PAWN_POSITION = '1b6/1Pk5/8/8/8/5K2/6P1/8 w - - 0 1';\nconst PREVENT_PROMOTION_POSITION = '8/bPk5/5KP1/8/8/8/8/8 w - - 1 20';\n\nexport const pieceValues = {\n\tp: 1,\n\tn: 3,\n\tb: 3,\n\tr: 5,\n\tq: 9,\n};\n\n/* Counts number of occorunces of substr in str */\nexport function countOccurences(str, substr) {\n\treturn str.split(substr).length - 1;\n}\n\n/* checks if all values in an array are defined */\nfunction allDefined(arr) {\n\tfor (let member of arr) {\n\t\tif (member === undefined) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/* returns whether a move is quiet (a non-capture) or not */\n// export function isQuietMove(move) {\n//     return !move.includes('x');\n// }\nexport function isQuietMove(game, move) {\n\t// check if there is a piece on new square (capture)\n\treturn game.get(move.to) === null;\n}\n\n/* counts number of pieces on board given FEN */\nfunction countNumberOfPiecesOnBoard(fen) {\n\tfen = fen.split(' ')[0]; // just the position\n\tfen = fen.replace(/[0-9/]/g, ''); // removes all numbers and slashes\n\treturn fen.length;\n}\n\nexport default function App({ boardWidth }) {\n\tconst chessboardRef = useRef();\n\tconst [game, setGame] = useState(new Chess());\n\tconst [engineDepth, setEngineDepth] = useState(4);\n\tconst [quiescenceDepth, setQuiescenceDepth] = useState(4);\n    const [isFirstMove, setIsFirstMove] = useState(true);\n\tconst [arrows, setArrows] = useState([]);\n\tconst [boardOrientation, setBoardOrientation] = useState('white');\n\tconst [currentTimeout, setCurrentTimeout] = useState(undefined);\n\tconst [numPiecesOnBoard, setNumPiecesOnBoard] = useState(\n\t\tcountNumberOfPiecesOnBoard(game.fen())\n\t);\n\n\t// console.log(game.get('a3'));\n\tlet nodes = 0;\n\tlet sortingTime = 0;\n\tlet quiescenceTime = 0;\n\tlet moveGenerationTime = 0;\n\tlet positionEvalTime = 0;\n\n\tfunction safeGameMutate(modify) {\n\t\tsetGame((g) => {\n\t\t\tconst update = { ...g };\n\t\t\tmodify(update);\n\t\t\treturn update;\n\t\t});\n\t}\n\n\t// minimax search with alpha-beta pruning\n\tfunction minimax(\n\t\tdepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n\t\talpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY\n\t) {\n\t\tnodes++;\n\t\t// Base case: evaluate board\n\t\tif (depth === 0) {\n            // check for quiet moves (non-captures)\n            if (isQuietMove(mostRecentMove)) {\n\t\t\t    return positionEval(playerColor) + moveEval;\n            } else {\n\t\t\t\t// const startTime = performance.now();\n                const quiescence = quiescenceSearch(\n                    quiescenceDepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n                    alpha, beta\n                );\n\t\t\t\t// const endTime = performance.now();\n\t\t\t\t// quiescenceTime += endTime - startTime;\n\t\t\t\treturn quiescence;\n            }\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tconst startTime = performance.now();\n\t\tlet possibleMoves = game.moves();\n\t\tconst endTime = performance.now();\n\t\tmoveGenerationTime += endTime - startTime;\n\t\t// Sort moves to put captures first\n\t\t// console.log('presort', possibleMoves);\n\t\t// const startTime = performance.now();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n\t\t// const endTime = performance.now();\n\t\t// sortingTime += (endTime - startTime);\n\t\t// console.log('postsort', possibleMoves);\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = minimax(depth-1, !isMaximizingPlayer, playerColor, moveEval, move, alpha, beta);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n    // does additional analysis on \"non-quiet\" moves i.e. captures\n    function quiescenceSearch(\n\t\tdepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n\t\talpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY\n\t) {\n\t\tnodes++;\n\n\t\t// evaluate position\n\t\tconst evaluation = positionEval(playerColor) + moveEval;\n\t\t// fail-hard beta cutoff (piece cut off so it prevents things like promotions)\n\t\tif (evaluation >= beta && numPiecesOnBoard >= 8) \n\t\t{\n\t\t\t// node (move) fails high\n\t\t\treturn beta;\n\t\t}\n\n        // console.log('Quiescence search', mostRecentMove);\n\t\t// Base case: evaluate board\n\t\tif (isQuietMove(mostRecentMove) || depth === 0) {\n            // console.log('Quiescence search', mostRecentMove);\n\t\t\treturn evaluation;\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tconst startTime = performance.now();\n\t\tlet possibleMoves = game.moves();\n\t\tconst endTime = performance.now();\n\t\tmoveGenerationTime += endTime - startTime;\n\t\t// console.log('presort', possibleMoves);\n\t\t// const startTime = performance.now();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n\t\t// const endTime = performance.now();\n\t\t// sortingTime += endTime - startTime;\n\t\t// console.log('postsort', possibleMoves);\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = quiescenceSearch(depth-1, !isMaximizingPlayer, playerColor, moveEval, move, alpha, beta);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n\tfunction computerMove() {\n        // if (isFirstMove) {\n        //     game.move('d5');\n        //     setIsFirstMove(false);\n        //     return;\n        // }\n\n\t\t// TODO : change moveEval if threading is brought back\n\n        const startTime = performance.now();\n\n\t\tlet possibleMoves = game.moves();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n\n\t\tlet bestEval = Number.NEGATIVE_INFINITY;\n\t\tlet bestMove;\n\n\t\t// Evaluate first 3 moves (highest values in MVV-LVA) \n\t\t// on main thread for alpha values for worker threads\n\t\tconst startTime2 = performance.now();\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tconst posMove = possibleMoves[i];\n\t\t\tgame.move(posMove);\n\t\t\tconst squareEval = moveEval(posMove);\n\t\t\tconst score = minimax(engineDepth, false, 'black', squareEval, posMove, bestEval);\n\t\t\tgame.undo();\n\t\t\tif (score > bestEval) {\n\t\t\t\tbestEval = score;\n\t\t\t\tbestMove = posMove;\n\t\t\t}\n\t\t}\n\t\tconst endTime2 = performance.now();\n\t\tconsole.log('first 3 took: ', (endTime2 - startTime2));\n\n\t\t// remove first 3 moves from possible moves\n\t\tpossibleMoves = possibleMoves.slice(3);\n\n\t\tconst workers = [];\n\t\t// Most moves evaluated on 3 threads with remainder on main thread\n\t\tconst workerChunk = Math.floor(possibleMoves.length / NUM_THREADS);\n\t\tconst mainThreadStart = workerChunk * NUM_THREADS;\n\t\tlet numWorkersDone = 0;\n\n\t\tfor (let i = 0; i < NUM_THREADS; i++) {\n\t\t\tworkers[i] = new Worker(new URL('./worker.js', import.meta.url));\n\t\t\tworkers[i].postMessage({\n\t\t\t\tdepth: engineDepth,\n\t\t\t\tquiescenceDepth: quiescenceDepth,\n\t\t\t\tposMoves: possibleMoves.slice(i * workerChunk, (i + 1) * workerChunk),\n\t\t\t\tgameFEN: game.fen(),\n\t\t\t\talpha: bestEval,\n\t\t\t});\n\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\tworkers[i].onmessage = (msg) => {\n\t\t\t\tnumWorkersDone++;\n\n\t\t\t\tconst msgEval = msg.data[0];\n\t\t\t\tconst msgMove = msg.data[1];\n\t\t\t\tif (msgEval > bestEval) {\n\t\t\t\t\tbestEval = msgEval;\n\t\t\t\t\tbestMove = msgMove;\n\t\t\t\t}\n\n                // check if all workers done\n\t\t\t\tif (numWorkersDone === NUM_THREADS) {\n\t\t\t\t\tconsole.log('bestmove', bestEval, bestMove);\n\t\t\t\t\tsafeGameMutate((g) => g.move(bestMove));\n                    \n                    // log total time taken\n                    const endTime = performance.now();\n\t\t            console.log(`TOTAL TIME took ${(endTime - startTime)/1000} seconds`);\n\t\t\t\t\tconsole.log('nodes checked', nodes);\n\t\t\t\t\tnodes = 0;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Finish last few moves on main thread\n\t\tfor (let i = mainThreadStart; i < possibleMoves.length; i++) {\n\t\t\tconst posMove = possibleMoves[i];\n\t\t\tgame.move(posMove);\n\t\t\tconst squareEval = moveEval(posMove);\n\t\t\tconst score = minimax(engineDepth, false, 'black', squareEval, posMove, bestEval);\n\t\t\tgame.undo();\n\t\t\tif (score > bestEval) {\n\t\t\t\tbestEval = score;\n\t\t\t\tbestMove = posMove;\n\t\t\t}\n\t\t}\n\n\t\t// const startTime = performance.now();\n\t\t// for (let i = 0; i < possibleMoves.length; i++) {\n\t\t// \tconst posMove = possibleMoves[i];\n\t\t// \tgame.move(posMove);\n\t\t// \t// console.log('posmove', posMove, moveEval(posMove));\n\t\t// \tconst squareEval = moveEval(posMove);\n\t\t// \tconst score = minimax(2, false, 'black', squareEval);\n\t\t// \tgame.undo();\n\t\t// \tif (score > bestEval) {\n\t\t// \t\tbestEval = score;\n\t\t// \t\tbestMove = posMove;\n\t\t// \t}\n\t\t// }\n\n\t\t// const endTime = performance.now();\n\t\t// console.log(`Call to minmax took ${(endTime - startTime)/1000} seconds`);\n\n\t\t// console.log('bestMove', bestMove);\n\t\t// safeGameMutate((g) => g.move(bestMove));\n\n\t\t// Pick a random score from all best moves\n\t\t// const maxScore = Math.max(...scores);\n\t\t// const maxScoreIndexes = [];\n\t\t// for (let i = 0; i < scores.length; i++) {\n\t\t// \tif (scores[i] === maxScore) {\n\t\t// \t\tmaxScoreIndexes.push(i);\n\t\t// \t}\n\t\t// }\n\n\t\t// const randomIndex = Math.floor(Math.random() * maxScoreIndexes.length);\n\t\t// console.log('randomindex', randomIndex);\n\t\t// const bestMove = possibleMoves[maxScoreIndexes[randomIndex]];\n\t\t// safeGameMutate((g) => g.move(bestMove));\n\t}\n\n    // unthreaded computerMove (testing purposes)\n    function unthreadedMove() {\n        // if (isFirstMove) {\n        //     game.move('d5');\n        //     setIsFirstMove(false);\n        //     return;\n        // }\n\t\t\n        const startTime = performance.now();\n\t\tlet possibleMoves = game.moves();\n\t\tconst endTime2 = performance.now();\n\t\tmoveGenerationTime += endTime2 - startTime;\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n        let bestEval = Number.NEGATIVE_INFINITY;\n        let bestMove;\n\n\t\t// do minimax on each move\n        for (let i = 0; i < possibleMoves.length; i++) {\n            const posMove = possibleMoves[i];\n            game.move(posMove);\n            const squareEval = moveEval(posMove, 'black', numPiecesOnBoard);\n\t\t\t// console.log('squareeval', posMove, squareEval);\n            const score = minimax(engineDepth-1, false, 'black', squareEval, posMove, bestEval);\n            game.undo();\n            if (score > bestEval) {\n                bestEval = score;\n                bestMove = posMove;\n            }\n        }\n\n\t\t// bestMove is undefined if checkmate in one for opponent\n\t\tif (bestMove === undefined && possibleMoves.length !== 0) {\n\t\t\tbestMove = possibleMoves[0];\n\t\t}\n\n        console.log('bestmove', bestEval, bestMove);\t\t\n        safeGameMutate((g) => g.move(bestMove));\n\t\t// update number of pieces on board\n\t\tsetNumPiecesOnBoard(countNumberOfPiecesOnBoard(game.fen()));\n\n        const endTime = performance.now();\n        console.log(`TOTAL TIME took ${(endTime - startTime)/1000} seconds`);\n\t\t// console.log(`TOTAL SORTING TIME took ${sortingTime/1000} seconds`);\n\t\t// console.log(`TOTAL QUIESCENCE TIME took ${quiescenceTime / 1000} seconds`);\n\t\tconsole.log(`total move generation time took ${moveGenerationTime / 1000} seconds`);\n\t\tconsole.log(`total position eval time took ${positionEvalTime / 1000} seconds`);\n\t\tconsole.log('nodes checked', nodes);\n\t\tnodes = 0;\n\t\tsortingTime = 0;\n\t\tquiescenceTime = 0;\n\t\tmoveGenerationTime = 0;\n\t\tpositionEvalTime = 0;\n    }\n\n\tfunction positionEval(playerColor) {\n\t\tconst startTime = performance.now();\n\n\n\t\tlet position = game.fen().split(' ')[0];\n\t\tlet score = 0;\n\n\t\tObject.keys(pieceValues).forEach((key) => {\n\t\t\tscore += countOccurences(position, key.toUpperCase()) * pieceValues[key]; // white pieces\n\t\t\tscore -= countOccurences(position, key) * pieceValues[key]; // black pieces\n\t\t});\n\n\t\tconst endTime = performance.now();\n\t\tpositionEvalTime += endTime - startTime;\n\n\t\treturn playerColor === 'white' ? score : -score; // invert if computer is black\n\t}\n\n\tfunction onDrop(sourceSquare, targetSquare) {\n\t\tconst gameCopy = { ...game };\n\t\tconst move = gameCopy.move({\n\t\t\tfrom: sourceSquare,\n\t\t\tto: targetSquare,\n\t\t\tpromotion: 'q', // always promote to a queen for example simplicity\n\t\t});\n\t\tsetGame(gameCopy);\n\t\tsetNumPiecesOnBoard(countNumberOfPiecesOnBoard(gameCopy.fen()));\n\n\t\t// hike up the depth in endgame\n\t\tif (numPiecesOnBoard <= 8 && engineDepth < 5) {\n\t\t\tconsole.log('hiked!');\n\t\t\tsetEngineDepth(engineDepth + 1);\n\t\t}\n\t\t// hike it up even more\n\t\tif (numPiecesOnBoard <= 5 && engineDepth < 6) {\n\t\t\tconsole.log('more!');\n\t\t\tsetEngineDepth(engineDepth + 1);\n\t\t}\n\n\t\t// illegal move\n\t\tif (move === null) return false;\n\n\t\t// store timeout so it can be cleared on undo/reset so computer doesn't execute move\n\t\tconst newTimeout = setTimeout(unthreadedMove, 300);\n\t\tsetCurrentTimeout(newTimeout);\n\t\treturn true;\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<Chessboard\n\t\t\t\tid=\"PlayVsRandom\"\n\t\t\t\tanimationDuration={200}\n\t\t\t\tboardOrientation={boardOrientation}\n\t\t\t\tboardWidth={boardWidth}\n\t\t\t\tcustomArrows={arrows}\n\t\t\t\tposition={game.fen()}\n\t\t\t\tonPieceDrop={onDrop}\n\t\t\t\tcustomBoardStyle={{\n\t\t\t\t\tborderRadius: '4px',\n\t\t\t\t\tboxShadow: '0 5px 15px rgba(0, 0, 0, 0.5)',\n\t\t\t\t}}\n\t\t\t\tref={chessboardRef}\n\t\t\t/>\n\t\t\t<p>History: {game.history().map((move) => move + '\\n')}</p>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsafeGameMutate((game) => {\n\t\t\t\t\t\tgame.reset();\n\t\t\t\t\t});\n\t\t\t\t\t// stop any current timeouts\n\t\t\t\t\tclearTimeout(currentTimeout);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\treset\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsetBoardOrientation((currentOrientation) =>\n\t\t\t\t\t\tcurrentOrientation === 'white' ? 'black' : 'white'\n\t\t\t\t\t);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tflip board\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsafeGameMutate((game) => {\n\t\t\t\t\t\tgame.undo();\n\t\t\t\t\t});\n\t\t\t\t\t// stop any current timeouts\n\t\t\t\t\tclearTimeout(currentTimeout);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tundo\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsetArrows([\n\t\t\t\t\t\t['a3', 'a5'],\n\t\t\t\t\t\t['g1', 'f3'],\n\t\t\t\t\t]);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tSet Custom Arrows\n\t\t\t</button>\n\n\t\t\t{/* Select Depth */}\n\t\t\t<label htmlFor=\"depth\">Depth: </label>\n\t\t\t<select\n\t\t\t\tname=\"depth\"\n\t\t\t\tid=\"depth\"\n\t\t\t\tonChange={(e) => setEngineDepth(Number(e.target.value))}\n\t\t\t\tdefaultValue=\"4\"\n\t\t\t>\n\t\t\t\t<option value=\"3\">3</option>\n\t\t\t\t<option value=\"4\">4</option>\n\t\t\t\t<option value=\"5\">5</option>\n\t\t\t\t<option value=\"6\">6</option>\n\t\t\t</select>\n\n\t\t\t{/* Select quiescence depth */}\n\t\t\t<label htmlFor=\"quiescence\">Quiescence depth: </label>\n\t\t\t<select\n\t\t\t\tname=\"quiescence\"\n\t\t\t\tid=\"depth\"\n\t\t\t\tonChange={(e) => setQuiescenceDepth(Number(e.target.value))}\n\t\t\t\tdefaultValue=\"4\"\n\t\t\t>\n\t\t\t\t<option value=\"2\">2</option>\n\t\t\t\t<option value=\"3\">3</option>\n\t\t\t\t<option value=\"4\">4</option>\n\t\t\t\t<option value=\"5\">5</option>\n\t\t\t</select>\n\t\t</div>\n\t);\n}\n","import { Chess } from 'chess.js';\nimport { countOccurences, isQuietMove, pieceValues } from './App';\nimport { moveEval, sortMoves } from './PositionEval';\n\n// Calculates a minimax score at depth\nonmessage = (msg) => {\n\tconst startTime = performance.now();\n\tconst { depth, quiescenceDepth, posMoves, gameFEN, alpha } = msg.data;\n\tconst game = new Chess(gameFEN);\n\t// let scores = [];\n    let bestEval = Number.NEGATIVE_INFINITY;\n    let bestMove;\n\n    console.log('posMoves', posMoves);\n\n\tfor (let posMove of posMoves) {\n\t\tgame.move(posMove);\n        const squareEval = moveEval(posMove);\n\t\tconst score = minimax(depth-1, false, 'black', squareEval, posMove, alpha);\n        if (score > bestEval) {\n            bestEval = score;\n            bestMove = posMove;\n        }\n\t\tgame.undo();\n\t}\n\n    const endTime = performance.now();\n    console.log(`Call to minmax took ${(endTime - startTime)/1000} seconds`);\n\n\tpostMessage([bestEval, bestMove]);\n\n\tfunction minimax(\n\t\tdepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n\t\talpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY\n\t) {\n\t\t// Base case: evaluate board\n\t\tif (depth === 0) {\n            // check for quiet moves (non-captures)\n            if (isQuietMove(mostRecentMove)) {\n\t\t\t    return positionEval(playerColor) + moveEval;\n            } else {\n                const quiescence = quiescenceSearch(\n                    quiescenceDepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n                    alpha, beta\n                );\n\t\t\t\treturn quiescence;\n            }\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tlet possibleMoves = game.moves();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// if (!isQuietMove(move)) {\n\t\t\t\t// console.log(move, 'NOT QUIET. CAPTURE EVAL: ', getCaptureValue(game, move));\n\t\t\t\t// console.log(game.ascii());\n\t\t\t// }\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = minimax(depth-1, !isMaximizingPlayer, playerColor, moveEval, move, alpha, beta);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n\tfunction quiescenceSearch(\n\t\tdepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n\t\talpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY\n\t) {\n\t\tconst evaluation = positionEval(playerColor) + moveEval;\n\t\t// fail-hard beta cutoff\n\t\tif (evaluation >= beta)\n\t\t{\n\t\t\t// node (move) fails high\n\t\t\treturn beta;\n\t\t}\n\n        // console.log('Quiescence search', mostRecentMove);\n\t\t// Base case: evaluate board\n\t\tif (isQuietMove(mostRecentMove) || depth === 0) {\n            // console.log('Quiescence search', mostRecentMove);\n\t\t\treturn positionEval(playerColor) + moveEval;\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tlet possibleMoves = game.moves();\n\t\t// console.log('presort', possibleMoves);\n\t\t// const startTime = performance.now();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n\t\t// const endTime = performance.now();\n\t\t// sortingTime += endTime - startTime;\n\t\t// console.log('postsort', possibleMoves);\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = quiescenceSearch(depth-1, !isMaximizingPlayer, playerColor, moveEval, move, alpha, beta);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n\tfunction positionEval(playerColor) {\n\t\tlet position = game.fen().split(' ')[0];\n\t\tlet score = 0;\n\n\t\tObject.keys(pieceValues).forEach((key) => {\n\t\t\tscore += countOccurences(position, key.toUpperCase()) * pieceValues[key]; // white pieces\n\t\t\tscore -= countOccurences(position, key) * pieceValues[key]; // black pieces\n\t\t});\n\n\t\treturn playerColor === 'white' ? score : -score; // invert if computer is black\n\t}\n};\n"],"names":["MVV_LVA","p","n","b","r","q","k","bestSquares","endgameSquares","stripped_san","move","replace","moveEval","color","numPiecesOnBoard","moveValue","includes","piece","toLowerCase","rank","file","square","slice","length","charCodeAt","console","log","getMoveValue","game","isQuietMove","value","pieceValues","attacker","victimSquare","victim","get","type","getCaptureValue","e","sortMoves","moves","moveScores","i","current_move","next_move","temp_score","temp_move","navigator","hardwareConcurrency","countOccurences","str","substr","split","to","onmessage","msg","bestMove","startTime","performance","now","data","depth","quiescenceDepth","posMoves","gameFEN","alpha","Chess","bestEval","Number","NEGATIVE_INFINITY","posMove","score","minimax","undo","endTime","isMaximizingPlayer","playerColor","mostRecentMove","beta","POSITIVE_INFINITY","positionEval","quiescence","quiescenceSearch","possibleMoves","bestMoveValue","Math","max","min","evaluation","position","fen","Object","keys","forEach","key","toUpperCase","postMessage"],"sourceRoot":""}