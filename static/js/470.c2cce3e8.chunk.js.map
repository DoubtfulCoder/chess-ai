{"version":3,"file":"static/js/470.c2cce3e8.chunk.js","mappings":"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","sources":["PositionEval.js","App.js","worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["// Best squares for different pieces to be on (black's perspective) \nexport const bestSquares = {\n\t// pawns usually better in center\n\t// prettier-ignore\n\t'p': [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.3, 0.3, 0.2, 0.3, 0.3, 0.1, 0.3, 0.3],\n\t\t[0.2, 0.1, 0.4, 0.5, 0.5, 0.1, 0.1, 0.1],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// knights better towards center not edges\n\t// prettier-ignore\n\t'n': [\n\t\t[0.0,-0.1, 0.0, 0.0, 0.0, 0.0,-0.1, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0],\n\t\t[-0.1,0.0, 0.4, 0.0, 0.0, 0.4, 0.0, -0.1],\n\t\t[0.0, 0.0, 0.0, 0.3, 0.3, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// prettier-ignore\n\t'b': [\n\t\t[0.0, 0.0,-0.1, 0.0, 0.0,-0.1, 0.0, 0.0],\n\t\t[0.0, 0.3, 0.0, 0.1, 0.1, 0.0, 0.3, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.3, 0.0, 0.0, 0.3, 0.0, 0.0],\n\t\t[0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\tr: [\n\t\t[0.0, 0.0, 0.2, 0.3, 0.3, 0.2, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\tq: [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n};\n\n// strip off any move decorations: e.g Nf3+?! becomes Nf3\nfunction stripped_san(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\n// gets move in SAN (e.g. Nc4) and gets corresponding eval from bestSquares\nexport function moveEval(move, color='black') {\n    // castling is +0.7\n    if (move.includes('O-O')) { return 0.7; }\n    // promotion is +9\n    if (move.includes('=')) { return 9; }\n    // discourage checks TODO : make this only for first 15 moves\n    if (move.includes('+')) { return -0.5; }\n\n    move = stripped_san(move); // remove decorations like +!?# at end\n\t// piece code is always first char for non-pawns\n\tlet piece = move[0];\n    if (piece === 'K') { // nothing for king in bestSquares yet\n        return 0;\n    } else if (piece !== 'B' && piece !== 'N' && piece !== 'R' && piece !== 'Q') {\n        piece = 'p';\n    }\n    piece = piece.toLowerCase();\n\tconst square = move.slice(move.length - 2, move.length); // square is always last two chars\n\n\t// convert characters to numbers\n    let rank;\n    let file;\n    if (color === 'white') {\n        rank = square.charCodeAt(0) - 97;\n        file = square.charCodeAt(1) - 49;\n    } else {\n        rank = square.charCodeAt(0) - 97;\n        file = 7 - (square.charCodeAt(1) - 49);\n    }\n\treturn bestSquares[piece][file][rank];\n}\n\n// TODO : code below may help with from square \n// function getEval(move) {\n//     const san = move.san;\n//     const piece = san[0];\n//     const from = san.slice(1, 3);\n//     const to = san.slice(3, 5);\n//     const fromSquare = chess.square(from);\n//     const toSquare = chess.square(to);\n//     const pieceEval = bestSquares[piece][toSquare];\n//     return pieceEval;\n// }","import { Chess } from 'chess.js';\nimport { useRef, useState } from 'react';\nimport { Chessboard } from 'react-chessboard';\nimport { moveEval } from './PositionEval';\n\n// console.log('Qd6', moveEval('Qd6', 'black'));\n\nexport const pieceValues = {\n\tp: 1,\n\tn: 3,\n\tb: 3,\n\tr: 5,\n\tq: 9,\n};\n\n/* Counts number of occorunces of substr in str */\nexport function countOccurences(str, substr) {\n\treturn str.split(substr).length - 1;\n}\n\n/* checks if all values in an array are defined */\nfunction allDefined(arr) {\n\tfor (let member of arr) {\n\t\tif (member === undefined) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nexport default function App({ boardWidth }) {\n\tconst chessboardRef = useRef();\n\tconst [game, setGame] = useState(new Chess());\n    const [isFirstMove, setIsFirstMove] = useState(true);\n\tconst [arrows, setArrows] = useState([]);\n\tconst [boardOrientation, setBoardOrientation] = useState('white');\n\tconst [currentTimeout, setCurrentTimeout] = useState(undefined);\n\n\tfunction safeGameMutate(modify) {\n\t\tsetGame((g) => {\n\t\t\tconst update = { ...g };\n\t\t\tmodify(update);\n\t\t\treturn update;\n\t\t});\n\t}\n\n\tfunction minimax(\n\t\tdepth,\n\t\tisMaximizingPlayer,\n\t\tplayerColor,\n        moveEval,\n\t\talpha = Number.NEGATIVE_INFINITY,\n\t\tbeta = Number.POSITIVE_INFINITY\n\t) {\n\t\t// Base case: evaluate board\n\t\tif (depth === 0) {\n\t\t\treturn positionEval(playerColor) + moveEval;\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tconst possibleMoves = game.moves();\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = minimax(\n\t\t\t\tdepth - 1,\n\t\t\t\t!isMaximizingPlayer,\n\t\t\t\tplayerColor,\n\t\t\t\tmoveEval,\n\t\t\t\talpha,\n\t\t\t\tbeta\n\t\t\t);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n\tfunction computerMove() {\n        if (isFirstMove) {\n            game.move('d5');\n            setIsFirstMove(false);\n            return;\n        }\n\t\tconst possibleMoves = game.moves();\n\t\tconst workers = [];\n\t\t// Most moves evaluated on 3 threads with remainder on main thread\n\t\tconst workerChunk = Math.floor(possibleMoves.length / 3);\n\t\tconst mainThreadStart = workerChunk * 3;\n\t\tlet numWorkersDone = 0;\n\n\t\tlet bestEval = Number.NEGATIVE_INFINITY;\n\t\tlet bestMove;\n\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tworkers[i] = new Worker(new URL('./worker.js', import.meta.url));\n\t\t\tworkers[i].postMessage({\n\t\t\t\tdepth: 4,\n\t\t\t\tisMaximizingPlayer: true,\n\t\t\t\tposMoves: possibleMoves.slice(i * workerChunk, (i + 1) * workerChunk),\n\t\t\t\tgameFEN: game.fen(),\n\t\t\t});\n\t\t\tworkers[i].onmessage = (msg) => {\n\t\t\t\tnumWorkersDone++;\n\n\t\t\t\tconst msgEval = msg.data[0];\n\t\t\t\tconst msgMove = msg.data[1];\n\t\t\t\tif (msgEval > bestEval) {\n\t\t\t\t\tbestEval = msgEval;\n\t\t\t\t\tbestMove = msgMove;\n\t\t\t\t}\n\n\t\t\t\tif (numWorkersDone === 3) {\n\t\t\t\t\tconsole.log('bestmove', bestEval, bestMove);\n\t\t\t\t\tsafeGameMutate((g) => g.move(bestMove));\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Finish last few moves on main thread\n\t\tconst startTime = performance.now();\n\t\tfor (let i = mainThreadStart; i < possibleMoves.length; i++) {\n\t\t\tconst posMove = possibleMoves[i];\n\t\t\tgame.move(posMove);\n\t\t\tconst squareEval = moveEval(posMove);\n\t\t\tconst score = minimax(3, false, 'black', squareEval);\n\t\t\tgame.undo();\n\t\t\tif (score > bestEval) {\n\t\t\t\tbestEval = score;\n\t\t\t\tbestMove = posMove;\n\t\t\t}\n\t\t}\n\n\t\tconst endTime = performance.now();\n\t\tconsole.log(`MAIN THREAD: minmax took ${(endTime - startTime)/1000} seconds`);\n\n\t\t// const startTime = performance.now();\n\t\t// for (let i = 0; i < possibleMoves.length; i++) {\n\t\t// \tconst posMove = possibleMoves[i];\n\t\t// \tgame.move(posMove);\n\t\t// \t// console.log('posmove', posMove, moveEval(posMove));\n\t\t// \tconst squareEval = moveEval(posMove);\n\t\t// \tconst score = minimax(2, false, 'black', squareEval);\n\t\t// \tgame.undo();\n\t\t// \tif (score > bestEval) {\n\t\t// \t\tbestEval = score;\n\t\t// \t\tbestMove = posMove;\n\t\t// \t}\n\t\t// }\n\n\t\t// const endTime = performance.now();\n\t\t// console.log(`Call to minmax took ${(endTime - startTime)/1000} seconds`);\n\n\t\t// console.log('bestMove', bestMove);\n\t\t// safeGameMutate((g) => g.move(bestMove));\n\n\t\t// Pick a random score from all best moves\n\t\t// const maxScore = Math.max(...scores);\n\t\t// const maxScoreIndexes = [];\n\t\t// for (let i = 0; i < scores.length; i++) {\n\t\t// \tif (scores[i] === maxScore) {\n\t\t// \t\tmaxScoreIndexes.push(i);\n\t\t// \t}\n\t\t// }\n\n\t\t// const randomIndex = Math.floor(Math.random() * maxScoreIndexes.length);\n\t\t// console.log('randomindex', randomIndex);\n\t\t// const bestMove = possibleMoves[maxScoreIndexes[randomIndex]];\n\t\t// safeGameMutate((g) => g.move(bestMove));\n\t}\n\n\tfunction positionEval(playerColor) {\n\t\tlet position = game.fen().split(' ')[0];\n\t\tlet score = 0;\n\n\t\tObject.keys(pieceValues).forEach((key) => {\n\t\t\tscore += countOccurences(position, key.toUpperCase()) * pieceValues[key]; // white pieces\n\t\t\tscore -= countOccurences(position, key) * pieceValues[key]; // black pieces\n\t\t});\n\n\t\treturn playerColor === 'white' ? score : -score; // invert if computer is black\n\t}\n\n\tfunction onDrop(sourceSquare, targetSquare) {\n\t\tconst gameCopy = { ...game };\n\t\tconst move = gameCopy.move({\n\t\t\tfrom: sourceSquare,\n\t\t\tto: targetSquare,\n\t\t\tpromotion: 'q', // always promote to a queen for example simplicity\n\t\t});\n\t\tsetGame(gameCopy);\n\n\t\t// illegal move\n\t\tif (move === null) return false;\n\n\t\t// store timeout so it can be cleared on undo/reset so computer doesn't execute move\n\t\tconst newTimeout = setTimeout(computerMove, 200);\n\t\tsetCurrentTimeout(newTimeout);\n\t\treturn true;\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<Chessboard\n\t\t\t\tid=\"PlayVsRandom\"\n\t\t\t\tanimationDuration={200}\n\t\t\t\tboardOrientation={boardOrientation}\n\t\t\t\tboardWidth={boardWidth}\n\t\t\t\tcustomArrows={arrows}\n\t\t\t\tposition={game.fen()}\n\t\t\t\tonPieceDrop={onDrop}\n\t\t\t\tcustomBoardStyle={{\n\t\t\t\t\tborderRadius: '4px',\n\t\t\t\t\tboxShadow: '0 5px 15px rgba(0, 0, 0, 0.5)',\n\t\t\t\t}}\n\t\t\t\tref={chessboardRef}\n\t\t\t/>\n            <p>History: {game.history().map(move => move + '\\n')}</p>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsafeGameMutate((game) => {\n\t\t\t\t\t\tgame.reset();\n\t\t\t\t\t});\n\t\t\t\t\t// stop any current timeouts\n\t\t\t\t\tclearTimeout(currentTimeout);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\treset\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsetBoardOrientation((currentOrientation) =>\n\t\t\t\t\t\tcurrentOrientation === 'white' ? 'black' : 'white'\n\t\t\t\t\t);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tflip board\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsafeGameMutate((game) => {\n\t\t\t\t\t\tgame.undo();\n\t\t\t\t\t});\n\t\t\t\t\t// stop any current timeouts\n\t\t\t\t\tclearTimeout(currentTimeout);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tundo\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsetArrows([\n\t\t\t\t\t\t['a3', 'a5'],\n\t\t\t\t\t\t['g1', 'f3'],\n\t\t\t\t\t]);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tSet Custom Arrows\n\t\t\t</button>\n\t\t</div>\n\t);\n}\n","import { Chess } from 'chess.js';\nimport { countOccurences, pieceValues } from './App';\nimport { moveEval } from './PositionEval';\n\n// Calculates a minimax score at depth\nonmessage = (msg) => {\n\tconst startTime = performance.now();\n\tconst { depth, isMaximizingPlayer, posMoves, gameFEN } = msg.data;\n\tconst game = new Chess(gameFEN);\n\t// let scores = [];\n    let bestEval = Number.NEGATIVE_INFINITY;\n    let bestMove;\n\n    console.log('posMoves', posMoves);\n\n\tfor (let posMove of posMoves) {\n\t\tgame.move(posMove);\n        const squareEval = moveEval(posMove);\n\t\tconst score = minimax(depth-1, false, 'black', squareEval);\n        if (score > bestEval) {\n            bestEval = score;\n            bestMove = posMove;\n        }\n\t\tgame.undo();\n\t}\n\n    const endTime = performance.now();\n    console.log(`Call to minmax took ${(endTime - startTime)/1000} seconds`);\n\n\tpostMessage([bestEval, bestMove]);\n\n\tfunction minimax(\n\t\tdepth,\n\t\tisMaximizingPlayer,\n\t\tplayerColor,\n\t\tmoveEval,\n\t\talpha = Number.NEGATIVE_INFINITY,\n\t\tbeta = Number.POSITIVE_INFINITY\n\t) {\n\t\t// Base case: evaluate board\n\t\tif (depth === 0) {\n\t\t\treturn positionEval(playerColor) + moveEval;\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tconst possibleMoves = game.moves();\n\t\tlet bestMoveValue = isMaximizingPlayer\n\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = minimax(\n\t\t\t\tdepth - 1,\n\t\t\t\t!isMaximizingPlayer,\n\t\t\t\tplayerColor,\n\t\t\t\tmoveEval,\n\t\t\t\talpha,\n\t\t\t\tbeta\n\t\t\t);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn bestMoveValue;\n\t}\n\n\tfunction positionEval(playerColor) {\n\t\tlet position = game.fen().split(' ')[0];\n\t\tlet score = 0;\n\n\t\tObject.keys(pieceValues).forEach((key) => {\n\t\t\tscore += countOccurences(position, key.toUpperCase()) * pieceValues[key]; // white pieces\n\t\t\tscore -= countOccurences(position, key) * pieceValues[key]; // black pieces\n\t\t});\n\n\t\treturn playerColor === 'white' ? score : -score; // invert if computer is black\n\t}\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [408], function() { return __webpack_require__(470); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"408\":\"d0f93b06\",\"470\":\"c2cce3e8\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/chess-ai/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t470: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkchess_ai\"] = self[\"webpackChunkchess_ai\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(408).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["bestSquares","r","q","stripped_san","move","replace","moveEval","color","includes","piece","toLowerCase","rank","file","square","slice","length","charCodeAt","pieceValues","p","n","b","countOccurences","str","substr","split","onmessage","msg","bestMove","startTime","performance","now","data","depth","posMoves","isMaximizingPlayer","gameFEN","game","Chess","bestEval","Number","NEGATIVE_INFINITY","console","log","posMove","score","minimax","undo","endTime","playerColor","alpha","beta","POSITIVE_INFINITY","positionEval","possibleMoves","moves","bestMoveValue","i","Math","max","min","position","fen","Object","keys","forEach","key","toUpperCase","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","d","definition","o","defineProperty","enumerable","get","f","e","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","call","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","push","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}