{"version":3,"file":"static/js/470.c1c0833a.chunk.js","mappings":"0EAGaA,G,cAAU,CACtBC,EAAG,CAAEA,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDJ,EAAG,CAAED,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDH,EAAG,CAAEF,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDF,EAAG,CAAEH,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDD,EAAG,CAAEJ,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,KAChDA,EAAG,CAAEL,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,OAIpCC,EAAc,CAG1B,EAAK,CACJ,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAC9B,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAC1C,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,IACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAIrC,EAAK,CACJ,CAAC,GAAK,GAAK,EAAK,EAAK,EAAK,GAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,EAAE,GAAI,EAAK,GAAK,EAAK,EAAK,GAAK,GAAM,IACrC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAGrC,EAAK,CACJ,CAAC,EAAK,GAAK,GAAK,EAAK,GAAK,GAAK,EAAK,GACpC,CAAC,EAAK,GAAK,EAAK,GAAK,GAAK,EAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,GAAK,GAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,GAAK,EAAK,EAAK,GAAK,EAAK,GACpC,CAAC,EAAK,GAAK,EAAK,EAAK,EAAK,EAAK,GAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAErC,EAAK,CACJ,CAAC,EAAK,EAAK,GAAK,GAAK,GAAK,GAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAErC,EAAK,CACJ,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GACpC,CAAC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,KAKtC,SAASC,EAAaC,GAErB,OAAOA,EAAKC,QAAQ,cAAe,IAI7B,SAASC,EAASF,GAAsB,IAAhBG,EAAe,uDAAT,QAEjC,GAAIH,EAAKI,SAAS,OAAU,MAAO,GAEnC,GAAIJ,EAAKI,SAAS,KAAQ,OAAO,EAEjC,GAAIJ,EAAKI,SAAS,KAAQ,OAAQ,GAIrC,IAAIC,GAFDL,EAAOD,EAAaC,IAEN,GACd,GAAc,MAAVK,EACA,OAAO,EACU,MAAVA,GAA2B,MAAVA,GAA2B,MAAVA,GAA2B,MAAVA,IAC1DA,EAAQ,KAEZA,EAAQA,EAAMC,cACjB,IAGOC,EACAC,EAJDC,EAAST,EAAKU,MAAMV,EAAKW,OAAS,EAAGX,EAAKW,QAYhD,MAPiB,UAAVR,GACAI,EAAOE,EAAOG,WAAW,GAAK,GAC9BJ,EAAOC,EAAOG,WAAW,GAAK,KAE9BL,EAAOE,EAAOG,WAAW,GAAK,GAC9BJ,EAAO,GAAKC,EAAOG,WAAW,GAAK,KAEnCd,EAAYO,GAAOG,GAAMD,GA+B1B,SAASM,EAAaC,EAAMd,GAClC,GAAIe,EAAYf,GACf,OAAO,EAEP,IACC,OAhCI,SAAyBc,EAAMd,GAErC,IAAIgB,EAAQ,GADZhB,EAAOD,EAAaC,IAGXI,SAAS,OAEjBY,GAASC,EAAYjB,EAAKA,EAAKW,OAAS,GAAGL,eAC3CN,EAAOA,EAAKU,MAAM,EAAGV,EAAKW,OAAS,IAIpC,IAAIO,EAAWlB,EAAK,GACH,MAAbkB,GAAiC,MAAbA,GAAiC,MAAbA,GAAiC,MAAbA,GAAiC,MAAbA,IAC7EA,EAAW,KAEfA,EAAWA,EAASZ,cAIvB,IAAMa,EAAenB,EAAKU,MAAMV,EAAKW,OAAS,EAAGX,EAAKW,QAChDS,EAASN,EAAKO,IAAIF,GAAcG,KAAKhB,cAG3C,OADAU,EAASzB,EAAQ6B,GAAQF,GAUhBK,CAAgBT,EAAMd,GAC5B,MAAMwB,GAGP,OAAO,GAWH,SAASC,EAAUX,EAAMY,GAQ5B,IAHA,IAAIC,EAAa,GAGRC,EAAI,EAAGA,EAAIF,EAAMf,OAAQiB,IAC9BD,EAAWC,GAAKf,EAAaC,EAAMY,EAAME,IAI7C,IAAK,IAAIC,EAAe,EAAGA,EAAeH,EAAMf,OAAQkB,IAGpD,IAAK,IAAIC,EAAYD,EAAe,EAAGC,EAAYJ,EAAMf,OAAQmB,IAG7D,GAAIH,EAAWE,GAAgBF,EAAWG,GAC1C,CAEI,IAAIC,EAAaJ,EAAWE,GAC5BF,EAAWE,GAAgBF,EAAWG,GACtCH,EAAWG,GAAaC,EAGxB,IAAIC,EAAYN,EAAMG,GACtBH,EAAMG,GAAgBH,EAAMI,GAC5BJ,EAAMI,GAAaE,EAOlC,OAAON,E,OC5LRO,QAAQC,IAAI,qCAAsCC,UAAUC,qBAGxCD,UAAUC,oBAA9B,IAOanB,EAAc,CAC1BzB,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,GAIG,SAASyC,EAAgBC,EAAKC,GACpC,OAAOD,EAAIE,MAAMD,GAAQ5B,OAAS,EAc5B,SAASI,EAAYf,GACxB,OAAQA,EAAKI,SAAS,KCpC1BqC,UAAY,SAACC,GACZ,IAKOC,EALDC,EAAYC,YAAYC,MAC9B,EAA6DJ,EAAIK,KAAzDC,EAAR,EAAQA,MAAOC,EAAf,EAAeA,gBAAiBC,EAAhC,EAAgCA,SAAUC,EAA1C,EAA0CA,QAASC,EAAnD,EAAmDA,MAC7CtC,EAAO,IAAIuC,EAAAA,GAAMF,GAEhBG,EAAWC,OAAOC,kBAGtBvB,QAAQC,IAAI,WAAYgB,GARP,gBAUAA,GAVA,IAUpB,2BAA8B,CAAC,IAAtBO,EAAqB,QAC7B3C,EAAKd,KAAKyD,GACJ,IACAC,EAAQC,EAAQX,EAAM,GAAG,EAAO,QADb9C,EAASuD,GACyBA,EAASL,GAC1DM,EAAQJ,IACRA,EAAWI,EACXf,EAAWc,GAErB3C,EAAK8C,QAlBc,8BAqBjB,IAAMC,EAAUhB,YAAYC,MAK/B,SAASa,EACRX,EAAOc,EAAoBC,EAAa7D,EAAU8D,GAEhD,IADFZ,EACC,uDADOG,OAAOC,kBAAmBS,EACjC,uDADwCV,OAAOW,kBAGhD,GAAc,IAAVlB,EAAa,CAEP,GAAIjC,EAAYiD,GACrB,OAAOG,EAAaJ,GAAe7D,EAE1B,IAAMkE,EAAaC,EACfpB,EAAiBa,EAAoBC,EAAa7D,EAAU8D,EAC5DZ,EAAOa,GAEvB,OAAOG,EAKT,IAAIE,EAAgBxD,EAAKY,QACzB4C,EAAgB7C,EAAUX,EAAMwD,GAMhC,IALM,IAAIC,EAAgBT,EACrBP,OAAOC,kBACPD,OAAOW,kBAGHtC,EAAI,EAAGA,EAAI0C,EAAc3D,OAAQiB,IAAK,CAC9C,IAAM5B,EAAOsE,EAAc1C,GAM3Bd,EAAKd,KAAKA,GAEV,IAAM0D,EAAQC,EAAQX,EAAM,GAAIc,EAAoBC,EAAa7D,EAAUF,EAAMoD,EAAOa,GAiBxF,GAfIH,GAECJ,EAAQa,IACXA,EAAgBb,GAEjBN,EAAQoB,KAAKC,IAAIrB,EAAOM,KAGpBA,EAAQa,IACXA,EAAgBb,GAEjBO,EAAOO,KAAKE,IAAIT,EAAMP,IAEvB5C,EAAK8C,OAEDK,GAAQb,EAEX,MAII,OAAOmB,EAGd,SAASF,EACRrB,EAAOc,EAAoBC,EAAa7D,EAAU8D,GAEhD,IADFZ,EACC,uDADOG,OAAOC,kBAAmBS,EACjC,uDADwCV,OAAOW,kBAE1CS,EAAaR,EAAaJ,GAAe7D,EAE/C,GAAIyE,GAAcV,EAGjB,OAAOA,EAKR,GAAIlD,EAAYiD,IAA6B,IAAVhB,EAElC,OAAOmB,EAAaJ,GAAe7D,EAIpC,IAAIoE,EAAgBxD,EAAKY,QAGzB4C,EAAgB7C,EAAUX,EAAMwD,GAShC,IALM,IAAIC,EAAgBT,EACrBP,OAAOC,kBACPD,OAAOW,kBAGHtC,EAAI,EAAGA,EAAI0C,EAAc3D,OAAQiB,IAAK,CAC9C,IAAM5B,EAAOsE,EAAc1C,GAE3Bd,EAAKd,KAAKA,GAEV,IAAM0D,EAAQW,EAAiBrB,EAAM,GAAIc,EAAoBC,EAAa7D,EAAUF,EAAMoD,EAAOa,GAiBjG,GAfIH,GAECJ,EAAQa,IACXA,EAAgBb,GAEjBN,EAAQoB,KAAKC,IAAIrB,EAAOM,KAGpBA,EAAQa,IACXA,EAAgBb,GAEjBO,EAAOO,KAAKE,IAAIT,EAAMP,IAEvB5C,EAAK8C,OAEDK,GAAQb,EAEX,MAII,OAAOmB,EAGd,SAASJ,EAAaJ,GACrB,IAAIa,EAAW9D,EAAK+D,MAAMrC,MAAM,KAAK,GACjCkB,EAAQ,EAOZ,OALAoB,OAAOC,KAAK9D,GAAa+D,SAAQ,SAACC,GACjCvB,GAASrB,EAAgBuC,EAAUK,EAAIC,eAAiBjE,EAAYgE,GACpEvB,GAASrB,EAAgBuC,EAAUK,GAAOhE,EAAYgE,MAGhC,UAAhBlB,EAA0BL,GAASA,EAzIxCzB,QAAQC,IAAR,+BAAoC2B,EAAUjB,GAAW,IAAzD,aAEHuC,YAAY,CAAC7B,EAAUX,OC5BpByC,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,IAOV,OAHAE,EAAoBL,GAAUI,EAAQA,EAAOD,QAASJ,GAG/CK,EAAOD,QAIfJ,EAAoBO,EAAID,EAGxBN,EAAoBQ,EAAI,WAGvB,IAAIC,EAAsBT,EAAoBU,OAAEP,EAAW,CAAC,MAAM,WAAa,OAAOH,EAAoB,QAE1G,OADAS,EAAsBT,EAAoBU,EAAED,I,WChC7C,IAAIE,EAAW,GACfX,EAAoBU,EAAI,SAASE,EAAQC,EAAUC,EAAIC,GACtD,IAAGF,EAAH,CAMA,IAAIG,EAAeC,IACnB,IAAS1E,EAAI,EAAGA,EAAIoE,EAASrF,OAAQiB,IAAK,CACrCsE,EAAWF,EAASpE,GAAG,GACvBuE,EAAKH,EAASpE,GAAG,GACjBwE,EAAWJ,EAASpE,GAAG,GAE3B,IAJA,IAGI2E,GAAY,EACPC,EAAI,EAAGA,EAAIN,EAASvF,OAAQ6F,MACpB,EAAXJ,GAAsBC,GAAgBD,IAAatB,OAAOC,KAAKM,EAAoBU,GAAGU,OAAM,SAASxB,GAAO,OAAOI,EAAoBU,EAAEd,GAAKiB,EAASM,OAC3JN,EAASQ,OAAOF,IAAK,IAErBD,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbP,EAASU,OAAO9E,IAAK,GACrB,IAAIjC,EAAIwG,SACEX,IAAN7F,IAAiBsG,EAAStG,IAGhC,OAAOsG,EAzBNG,EAAWA,GAAY,EACvB,IAAI,IAAIxE,EAAIoE,EAASrF,OAAQiB,EAAI,GAAKoE,EAASpE,EAAI,GAAG,GAAKwE,EAAUxE,IAAKoE,EAASpE,GAAKoE,EAASpE,EAAI,GACrGoE,EAASpE,GAAK,CAACsE,EAAUC,EAAIC,I,GCJ/Bf,EAAoBsB,EAAI,SAASlB,EAASmB,GACzC,IAAI,IAAI3B,KAAO2B,EACXvB,EAAoBwB,EAAED,EAAY3B,KAASI,EAAoBwB,EAAEpB,EAASR,IAC5EH,OAAOgC,eAAerB,EAASR,EAAK,CAAE8B,YAAY,EAAM1F,IAAKuF,EAAW3B,MCJ3EI,EAAoB2B,EAAI,GAGxB3B,EAAoB7D,EAAI,SAASyF,GAChC,OAAOC,QAAQC,IAAIrC,OAAOC,KAAKM,EAAoB2B,GAAGI,QAAO,SAASC,EAAUpC,GAE/E,OADAI,EAAoB2B,EAAE/B,GAAKgC,EAASI,GAC7BA,IACL,MCNJhC,EAAoBiC,EAAI,SAASL,GAEhC,MAAO,aAAeA,EAAU,IAAM,CAAC,IAAM,WAAW,IAAM,YAAYA,GAAW,aCFtF5B,EAAoBkC,SAAW,SAASN,KCDxC5B,EAAoBmC,EAAI,WACvB,GAA0B,kBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOC,MAAQ,IAAIC,SAAS,cAAb,GACd,MAAOnG,GACR,GAAsB,kBAAXoG,OAAqB,OAAOA,QALjB,GCAxBvC,EAAoBwB,EAAI,SAASgB,EAAKC,GAAQ,OAAOhD,OAAOiD,UAAUC,eAAeC,KAAKJ,EAAKC,ICA/FzC,EAAoB7F,EAAI,a,WCAxB6F,EAAoB3F,EAAIwI,KAAKC,SAAW,aAIxC,IAAIC,EAAkB,CACrB,IAAK,GAkBN/C,EAAoB2B,EAAEpF,EAAI,SAASqF,EAASI,GAEvCe,EAAgBnB,IAElBoB,cAAchD,EAAoB7F,EAAI6F,EAAoBiC,EAAEL,KAK/D,IAAIqB,EAAqBJ,KAA2B,qBAAIA,KAA2B,sBAAK,GACpFK,EAA6BD,EAAmBE,KAAKC,KAAKH,GAC9DA,EAAmBE,KAzBA,SAASzF,GAC3B,IAAImD,EAAWnD,EAAK,GAChB2F,EAAc3F,EAAK,GACnB4F,EAAU5F,EAAK,GACnB,IAAI,IAAIuC,KAAYoD,EAChBrD,EAAoBwB,EAAE6B,EAAapD,KACrCD,EAAoBO,EAAEN,GAAYoD,EAAYpD,IAIhD,IADGqD,GAASA,EAAQtD,GACda,EAASvF,QACdyH,EAAgBlC,EAAS0C,OAAS,EACnCL,EAA2BxF,I,cCrB5B,IAAI8F,EAAOxD,EAAoBQ,EAC/BR,EAAoBQ,EAAI,WACvB,OAAOR,EAAoB7D,EAAE,KAAKsH,KAAKD,I,GCDdxD,EAAoBQ,I","sources":["PositionEval.js","App.js","worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { isQuietMove, pieceValues } from \"./App\";\n\n// Access using MVV_LVA[Victim][Attacker]\nexport const MVV_LVA = {\n\tp: { p: 105, n: 104, b: 103, r: 102, q: 101, k: 100 },\n\tn: { p: 205, n: 204, b: 203, r: 202, q: 201, k: 200 },\n\tb: { p: 305, n: 304, b: 303, r: 302, q: 301, k: 300 },\n\tr: { p: 405, n: 404, b: 403, r: 402, q: 401, k: 400 },\n\tq: { p: 505, n: 504, b: 503, r: 502, q: 501, k: 500 },\n\tk: { p: 605, n: 604, b: 603, r: 602, q: 601, k: 600 },\n};\n\n// Best squares for different pieces to be on (black's perspective) \nexport const bestSquares = {\n\t// pawns usually better in center\n\t// prettier-ignore\n\t'p': [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.3, 0.3, 0.2, 0.3, 0.3, 0.1, 0.3, 0.3],\n\t\t[0.2, 0.1, 0.4, 0.5, 0.5, 0.1, 0.1, 0.1],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// knights better towards center not edges\n\t// prettier-ignore\n\t'n': [\n\t\t[0.0,-0.1, 0.0, 0.0, 0.0, 0.0,-0.1, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0],\n\t\t[-0.1,0.0, 0.4, 0.0, 0.0, 0.4, 0.0, -0.1],\n\t\t[0.0, 0.0, 0.0, 0.3, 0.3, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t// prettier-ignore\n\t'b': [\n\t\t[0.0, 0.0,-0.1, 0.0, 0.0,-0.1, 0.0, 0.0],\n\t\t[0.0, 0.3, 0.0, 0.1, 0.1, 0.0, 0.3, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.3, 0.0, 0.0, 0.3, 0.0, 0.0],\n\t\t[0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t'r': [\n\t\t[0.0, 0.0, 0.2, 0.3, 0.3, 0.2, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n\t'q': [\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t\t[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t],\n};\n\n// strip off any move decorations: e.g Nf3+?! becomes Nf3\nfunction stripped_san(move) {\n\t//   return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n\treturn move.replace(/[+#]?[?!]*$/, '');\n}\n\n// gets move in SAN (e.g. Nc4) and gets corresponding eval from bestSquares\nexport function moveEval(move, color='black') {\n    // castling is +0.7\n    if (move.includes('O-O')) { return 0.7; }\n    // promotion is +9\n    if (move.includes('=')) { return 9; }\n    // discourage checks TODO : make this only for first 15 moves\n    if (move.includes('+')) { return -0.5; }\n\n    move = stripped_san(move); // remove decorations like +!?# at end\n\t// piece code is always first char for non-pawns\n\tlet piece = move[0];\n    if (piece === 'K') { // nothing for king in bestSquares yet\n        return 0;\n    } else if (piece !== 'B' && piece !== 'N' && piece !== 'R' && piece !== 'Q') {\n        piece = 'p';\n    }\n    piece = piece.toLowerCase();\n\tconst square = move.slice(move.length - 2, move.length); // square is always last two chars\n\n\t// convert characters to numbers\n    let rank;\n    let file;\n    if (color === 'white') {\n        rank = square.charCodeAt(0) - 97;\n        file = square.charCodeAt(1) - 49;\n    } else {\n        rank = square.charCodeAt(0) - 97;\n        file = 7 - (square.charCodeAt(1) - 49);\n    }\n\treturn bestSquares[piece][file][rank];\n}\n\n/* Gets the value of a capture using MVV-LVA table */\nexport function getCaptureValue(game, move) {\n\tmove = stripped_san(move); // remove decorations like +!?# at end\n\tlet value = 0;\n\t// check for promotion\n\tif (move.includes('=')) {\n\t\t// add promoted piece's value\n\t\tvalue += pieceValues[move[move.length - 1].toLowerCase()];\n\t\tmove = move.slice(0, move.length - 2); // remove promotion piece\n\t}\n\n\t// piece code is always first char for non-pawns\n\tlet attacker = move[0];\n\tif (attacker !== 'B' && attacker !== 'N' && attacker !== 'R' && attacker !== 'Q' && attacker !== 'K') {\n        attacker = 'p';\n    }\n    attacker = attacker.toLowerCase();\n\t\n\t// last two chars are victim square\n\t// TOOD : check en pessant\n\tconst victimSquare = move.slice(move.length - 2, move.length);\n\tconst victim = game.get(victimSquare).type.toLowerCase();\n\n\tvalue += MVV_LVA[victim][attacker]\n\treturn value;\n}\n\n/* Get value of move (captures given higher value) */\nexport function getMoveValue(game, move) {\n\tif (isQuietMove(move)) {\n\t\treturn 0;\n\t} else {\n\t\ttry {\n\t\t\treturn getCaptureValue(game, move);\n\t\t} catch(e) { // doesn't work on en pessant yet\n\t\t\t// console.error(e);\n\t\t\t// console.log(move);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n}\n\nfunction getMoveValueTEST(game, move) {\n\treturn 0;\n}\n\n/* Sorts moves in descending order by capture value */\nexport function sortMoves(game, moves) {\n\t// return moves.sort((a, b) => {\n\t// \treturn getMoveValue(game, b) - getMoveValue(game, a);\n\t// });\n\n    let moveScores = [];\n    \n    // score all moves \n    for (let i = 0; i < moves.length; i++) {\n        moveScores[i] = getMoveValue(game, moves[i]);\n\t}\n    \n    // loop over current move within a move list\n    for (let current_move = 0; current_move < moves.length; current_move++)\n    {\n        // loop over next move within a move list\n        for (let next_move = current_move + 1; next_move < moves.length; next_move++)\n        {\n            // compare current and next move scores\n            if (moveScores[current_move] < moveScores[next_move])\n            {\n                // swap scores\n                let temp_score = moveScores[current_move];\n                moveScores[current_move] = moveScores[next_move];\n                moveScores[next_move] = temp_score;\n                \n                // swap moves\n                let temp_move = moves[current_move];\n                moves[current_move] = moves[next_move];\n                moves[next_move] = temp_move;\n            }\n        }\n    }\n\n\t// console.log('moveScores', moveScores);\n\n\treturn moves;\n}\n\n// TODO : code below may help with from square \n// function getEval(move) {\n//     const san = move.san;\n//     const piece = san[0];\n//     const from = san.slice(1, 3);\n//     const to = san.slice(3, 5);\n//     const fromSquare = chess.square(from);\n//     const toSquare = chess.square(to);\n//     const pieceEval = bestSquares[piece][toSquare];\n//     return pieceEval;\n// }","import { Chess } from 'chess.js';\nimport { useRef, useState } from 'react';\nimport { Chessboard } from 'react-chessboard';\nimport { moveEval, sortMoves } from './PositionEval';\n\n// console.log('Qd6', moveEval('Qd6', 'black'));\nconsole.log('Number of threads on your device: ', navigator.hardwareConcurrency);\n\n// Gets number of threads on your device\nconst NUM_THREADS = navigator.hardwareConcurrency - 1;\n\n// Position constants\nconst QUEENS_RAID = 'rnb1k1nr/pppp1ppp/5q2/2b1p3/4P1Q1/2N5/PPPP1PPP/R1B1KBNR w KQkq - 4 4';\nconst MATE_IN_ONE = 'k7/4Q3/5R2/p7/4P3/2N5/PPPPBPPP/R1B1K1N1 w Q - 0 1';\nconst TRICKY_POSITION = 'r3k2r/p1ppqpb1/bn2pnp1/3PN3/4P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1';\n\nexport const pieceValues = {\n\tp: 1,\n\tn: 3,\n\tb: 3,\n\tr: 5,\n\tq: 9,\n};\n\n/* Counts number of occorunces of substr in str */\nexport function countOccurences(str, substr) {\n\treturn str.split(substr).length - 1;\n}\n\n/* checks if all values in an array are defined */\nfunction allDefined(arr) {\n\tfor (let member of arr) {\n\t\tif (member === undefined) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/* returns whether a move is quiet (a non-capture) or not */\nexport function isQuietMove(move) {\n    return !move.includes('x');\n}\n\nexport default function App({ boardWidth }) {\n\tconst chessboardRef = useRef();\n\tconst [game, setGame] = useState(new Chess());\n    const [isFirstMove, setIsFirstMove] = useState(true);\n\tconst [arrows, setArrows] = useState([]);\n\tconst [boardOrientation, setBoardOrientation] = useState('white');\n\tconst [currentTimeout, setCurrentTimeout] = useState(undefined);\n\tconst [engineDepth, setEngineDepth] = useState(4);\n\tconst [quiescenceDepth, setQuiescenceDepth] = useState(4);\n\n\n\t// console.log(game.get('a3'));\n\tlet nodes = 0;\n\tlet sortingTime = 0;\n\tlet quiescenceTime = 0;\n\n\tfunction safeGameMutate(modify) {\n\t\tsetGame((g) => {\n\t\t\tconst update = { ...g };\n\t\t\tmodify(update);\n\t\t\treturn update;\n\t\t});\n\t}\n\n\t// minimax search with alpha-beta pruning\n\tfunction minimax(\n\t\tdepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n\t\talpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY\n\t) {\n\t\tnodes++;\n\t\t// Base case: evaluate board\n\t\tif (depth === 0) {\n            // check for quiet moves (non-captures)\n            if (isQuietMove(mostRecentMove)) {\n\t\t\t    return positionEval(playerColor) + moveEval;\n            } else {\n\t\t\t\tconst startTime = performance.now();\n                const quiescence = quiescenceSearch(\n                    quiescenceDepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n                    alpha, beta\n                );\n\t\t\t\tconst endTime = performance.now();\n\t\t\t\tquiescenceTime += endTime - startTime;\n\t\t\t\treturn quiescence;\n            }\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tlet possibleMoves = game.moves();\n\t\t// Sort moves to put captures first\n\t\t// console.log('presort', possibleMoves);\n\t\t// const startTime = performance.now();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n\t\t// const endTime = performance.now();\n\t\t// sortingTime += (endTime - startTime);\n\t\t// console.log('postsort', possibleMoves);\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// if (!isQuietMove(move)) {\n\t\t\t\t// console.log(move, 'NOT QUIET. CAPTURE EVAL: ', getCaptureValue(game, move));\n\t\t\t\t// console.log(game.ascii());\n\t\t\t// }\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = minimax(depth-1, !isMaximizingPlayer, playerColor, moveEval, move, alpha, beta);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n    // does additional analysis on \"non-quiet\" moves i.e. captures\n    function quiescenceSearch(\n\t\tdepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n\t\talpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY\n\t) {\n\t\tnodes++;\n\n\t\t// evaluate position\n\t\tconst evaluation = positionEval(playerColor) + moveEval;\n\t\t// fail-hard beta cutoff\n\t\tif (evaluation >= beta)\n\t\t{\n\t\t\t// node (move) fails high\n\t\t\treturn beta;\n\t\t}\n\n        // console.log('Quiescence search', mostRecentMove);\n\t\t// Base case: evaluate board\n\t\tif (isQuietMove(mostRecentMove) || depth === 0) {\n            // console.log('Quiescence search', mostRecentMove);\n\t\t\treturn evaluation;\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tlet possibleMoves = game.moves();\n\t\t// console.log('presort', possibleMoves);\n\t\t// const startTime = performance.now();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n\t\t// const endTime = performance.now();\n\t\t// sortingTime += endTime - startTime;\n\t\t// console.log('postsort', possibleMoves);\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = quiescenceSearch(depth-1, !isMaximizingPlayer, playerColor, moveEval, move, alpha, beta);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n\tfunction computerMove() {\n        // if (isFirstMove) {\n        //     game.move('d5');\n        //     setIsFirstMove(false);\n        //     return;\n        // }\n        const startTime = performance.now();\n\n\t\tlet possibleMoves = game.moves();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n\n\t\tlet bestEval = Number.NEGATIVE_INFINITY;\n\t\tlet bestMove;\n\n\t\t// Evaluate first 3 moves (highest values in MVV-LVA) \n\t\t// on main thread for alpha values for worker threads\n\t\tconst startTime2 = performance.now();\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tconst posMove = possibleMoves[i];\n\t\t\tgame.move(posMove);\n\t\t\tconst squareEval = moveEval(posMove);\n\t\t\tconst score = minimax(engineDepth, false, 'black', squareEval, posMove, bestEval);\n\t\t\tgame.undo();\n\t\t\tif (score > bestEval) {\n\t\t\t\tbestEval = score;\n\t\t\t\tbestMove = posMove;\n\t\t\t}\n\t\t}\n\t\tconst endTime2 = performance.now();\n\t\tconsole.log('first 3 took: ', (endTime2 - startTime2));\n\n\t\t// remove first 3 moves from possible moves\n\t\tpossibleMoves = possibleMoves.slice(3);\n\n\t\tconst workers = [];\n\t\t// Most moves evaluated on 3 threads with remainder on main thread\n\t\tconst workerChunk = Math.floor(possibleMoves.length / NUM_THREADS);\n\t\tconst mainThreadStart = workerChunk * NUM_THREADS;\n\t\tlet numWorkersDone = 0;\n\n\t\tfor (let i = 0; i < NUM_THREADS; i++) {\n\t\t\tworkers[i] = new Worker(new URL('./worker.js', import.meta.url));\n\t\t\tworkers[i].postMessage({\n\t\t\t\tdepth: engineDepth,\n\t\t\t\tquiescenceDepth: quiescenceDepth,\n\t\t\t\tposMoves: possibleMoves.slice(i * workerChunk, (i + 1) * workerChunk),\n\t\t\t\tgameFEN: game.fen(),\n\t\t\t\talpha: bestEval,\n\t\t\t});\n\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\tworkers[i].onmessage = (msg) => {\n\t\t\t\tnumWorkersDone++;\n\n\t\t\t\tconst msgEval = msg.data[0];\n\t\t\t\tconst msgMove = msg.data[1];\n\t\t\t\tif (msgEval > bestEval) {\n\t\t\t\t\tbestEval = msgEval;\n\t\t\t\t\tbestMove = msgMove;\n\t\t\t\t}\n\n                // check if all workers done\n\t\t\t\tif (numWorkersDone === NUM_THREADS) {\n\t\t\t\t\tconsole.log('bestmove', bestEval, bestMove);\n\t\t\t\t\tsafeGameMutate((g) => g.move(bestMove));\n                    \n                    // log total time taken\n                    const endTime = performance.now();\n\t\t            console.log(`TOTAL TIME took ${(endTime - startTime)/1000} seconds`);\n\t\t\t\t\tconsole.log('nodes checked', nodes);\n\t\t\t\t\tnodes = 0;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Finish last few moves on main thread\n\t\tfor (let i = mainThreadStart; i < possibleMoves.length; i++) {\n\t\t\tconst posMove = possibleMoves[i];\n\t\t\tgame.move(posMove);\n\t\t\tconst squareEval = moveEval(posMove);\n\t\t\tconst score = minimax(engineDepth, false, 'black', squareEval, posMove, bestEval);\n\t\t\tgame.undo();\n\t\t\tif (score > bestEval) {\n\t\t\t\tbestEval = score;\n\t\t\t\tbestMove = posMove;\n\t\t\t}\n\t\t}\n\n\t\t// const startTime = performance.now();\n\t\t// for (let i = 0; i < possibleMoves.length; i++) {\n\t\t// \tconst posMove = possibleMoves[i];\n\t\t// \tgame.move(posMove);\n\t\t// \t// console.log('posmove', posMove, moveEval(posMove));\n\t\t// \tconst squareEval = moveEval(posMove);\n\t\t// \tconst score = minimax(2, false, 'black', squareEval);\n\t\t// \tgame.undo();\n\t\t// \tif (score > bestEval) {\n\t\t// \t\tbestEval = score;\n\t\t// \t\tbestMove = posMove;\n\t\t// \t}\n\t\t// }\n\n\t\t// const endTime = performance.now();\n\t\t// console.log(`Call to minmax took ${(endTime - startTime)/1000} seconds`);\n\n\t\t// console.log('bestMove', bestMove);\n\t\t// safeGameMutate((g) => g.move(bestMove));\n\n\t\t// Pick a random score from all best moves\n\t\t// const maxScore = Math.max(...scores);\n\t\t// const maxScoreIndexes = [];\n\t\t// for (let i = 0; i < scores.length; i++) {\n\t\t// \tif (scores[i] === maxScore) {\n\t\t// \t\tmaxScoreIndexes.push(i);\n\t\t// \t}\n\t\t// }\n\n\t\t// const randomIndex = Math.floor(Math.random() * maxScoreIndexes.length);\n\t\t// console.log('randomindex', randomIndex);\n\t\t// const bestMove = possibleMoves[maxScoreIndexes[randomIndex]];\n\t\t// safeGameMutate((g) => g.move(bestMove));\n\t}\n\n    // unthreaded computerMove (testing purposes)\n    function unthreadedMove() {\n        // if (isFirstMove) {\n        //     game.move('d5');\n        //     setIsFirstMove(false);\n        //     return;\n        // }\n        const startTime = performance.now();\n        let possibleMoves = game.moves();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n        let bestEval = Number.NEGATIVE_INFINITY;\n        let bestMove;\n\n\t\t// do minimax on each move\n        for (let i = 0; i < possibleMoves.length; i++) {\n            const posMove = possibleMoves[i];\n            game.move(posMove);\n            const squareEval = moveEval(posMove);\n            const score = minimax(engineDepth-1, false, 'black', squareEval, posMove, bestEval);\n            game.undo();\n            if (score > bestEval) {\n                bestEval = score;\n                bestMove = posMove;\n            }\n        }\n\n\t\t// bestMove is undefined if checkmate in one\n\t\tif (bestMove === undefined && possibleMoves.length !== 0) {\n\t\t\tbestMove = possibleMoves[0];\n\t\t}\n\n        console.log('bestmove', bestEval, bestMove);\n        safeGameMutate((g) => g.move(bestMove));\n        const endTime = performance.now();\n        console.log(`TOTAL TIME took ${(endTime - startTime)/1000} seconds`);\n\t\tconsole.log(`TOTAL SORTING TIME took ${sortingTime/1000} seconds`);\n\t\tconsole.log(`TOTAL QUIESCENCE TIME took ${quiescenceTime / 1000} seconds`);\n\t\tconsole.log('nodes checked', nodes);\n\t\tnodes = 0;\n\t\tsortingTime = 0;\n\t\tquiescenceTime = 0;\n    }\n\n\tfunction positionEval(playerColor) {\n\t\tlet position = game.fen().split(' ')[0];\n\t\tlet score = 0;\n\n\t\tObject.keys(pieceValues).forEach((key) => {\n\t\t\tscore += countOccurences(position, key.toUpperCase()) * pieceValues[key]; // white pieces\n\t\t\tscore -= countOccurences(position, key) * pieceValues[key]; // black pieces\n\t\t});\n\n\t\treturn playerColor === 'white' ? score : -score; // invert if computer is black\n\t}\n\n\tfunction onDrop(sourceSquare, targetSquare) {\n\t\tconst gameCopy = { ...game };\n\t\tconst move = gameCopy.move({\n\t\t\tfrom: sourceSquare,\n\t\t\tto: targetSquare,\n\t\t\tpromotion: 'q', // always promote to a queen for example simplicity\n\t\t});\n\t\tsetGame(gameCopy);\n\n\t\t// illegal move\n\t\tif (move === null) return false;\n\n\t\t// store timeout so it can be cleared on undo/reset so computer doesn't execute move\n\t\tconst newTimeout = setTimeout(unthreadedMove, 200);\n\t\tsetCurrentTimeout(newTimeout);\n\t\treturn true;\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<Chessboard\n\t\t\t\tid=\"PlayVsRandom\"\n\t\t\t\tanimationDuration={200}\n\t\t\t\tboardOrientation={boardOrientation}\n\t\t\t\tboardWidth={boardWidth}\n\t\t\t\tcustomArrows={arrows}\n\t\t\t\tposition={game.fen()}\n\t\t\t\tonPieceDrop={onDrop}\n\t\t\t\tcustomBoardStyle={{\n\t\t\t\t\tborderRadius: '4px',\n\t\t\t\t\tboxShadow: '0 5px 15px rgba(0, 0, 0, 0.5)',\n\t\t\t\t}}\n\t\t\t\tref={chessboardRef}\n\t\t\t/>\n\t\t\t<p>History: {game.history().map((move) => move + '\\n')}</p>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsafeGameMutate((game) => {\n\t\t\t\t\t\tgame.reset();\n\t\t\t\t\t});\n\t\t\t\t\t// stop any current timeouts\n\t\t\t\t\tclearTimeout(currentTimeout);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\treset\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsetBoardOrientation((currentOrientation) =>\n\t\t\t\t\t\tcurrentOrientation === 'white' ? 'black' : 'white'\n\t\t\t\t\t);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tflip board\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsafeGameMutate((game) => {\n\t\t\t\t\t\tgame.undo();\n\t\t\t\t\t});\n\t\t\t\t\t// stop any current timeouts\n\t\t\t\t\tclearTimeout(currentTimeout);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tundo\n\t\t\t</button>\n\t\t\t<button\n\t\t\t\tclassName=\"rc-button\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tsetArrows([\n\t\t\t\t\t\t['a3', 'a5'],\n\t\t\t\t\t\t['g1', 'f3'],\n\t\t\t\t\t]);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tSet Custom Arrows\n\t\t\t</button>\n\n\t\t\t{/* Select Depth */}\n\t\t\t<label htmlFor=\"depth\">Depth: </label>\n\t\t\t<select\n\t\t\t\tname=\"depth\"\n\t\t\t\tid=\"depth\"\n\t\t\t\tonChange={(e) => setEngineDepth(Number(e.target.value))}\n\t\t\t\tdefaultValue=\"4\"\n\t\t\t>\n\t\t\t\t<option value=\"3\">3</option>\n\t\t\t\t<option value=\"4\">4</option>\n\t\t\t\t<option value=\"5\">5</option>\n\t\t\t\t<option value=\"6\">6</option>\n\t\t\t</select>\n\n\t\t\t{/* Select quiescence depth */}\n\t\t\t<label htmlFor=\"quiescence\">Quiescence depth: </label>\n\t\t\t<select\n\t\t\t\tname=\"quiescence\"\n\t\t\t\tid=\"depth\"\n\t\t\t\tonChange={(e) => setQuiescenceDepth(Number(e.target.value))}\n\t\t\t\tdefaultValue=\"4\"\n\t\t\t>\n\t\t\t\t<option value=\"2\">2</option>\n\t\t\t\t<option value=\"3\">3</option>\n\t\t\t\t<option value=\"4\">4</option>\n\t\t\t\t<option value=\"5\">5</option>\n\t\t\t</select>\n\t\t</div>\n\t);\n}\n","import { Chess } from 'chess.js';\nimport { countOccurences, isQuietMove, pieceValues } from './App';\nimport { moveEval, sortMoves } from './PositionEval';\n\n// Calculates a minimax score at depth\nonmessage = (msg) => {\n\tconst startTime = performance.now();\n\tconst { depth, quiescenceDepth, posMoves, gameFEN, alpha } = msg.data;\n\tconst game = new Chess(gameFEN);\n\t// let scores = [];\n    let bestEval = Number.NEGATIVE_INFINITY;\n    let bestMove;\n\n    console.log('posMoves', posMoves);\n\n\tfor (let posMove of posMoves) {\n\t\tgame.move(posMove);\n        const squareEval = moveEval(posMove);\n\t\tconst score = minimax(depth-1, false, 'black', squareEval, posMove, alpha);\n        if (score > bestEval) {\n            bestEval = score;\n            bestMove = posMove;\n        }\n\t\tgame.undo();\n\t}\n\n    const endTime = performance.now();\n    console.log(`Call to minmax took ${(endTime - startTime)/1000} seconds`);\n\n\tpostMessage([bestEval, bestMove]);\n\n\tfunction minimax(\n\t\tdepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n\t\talpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY\n\t) {\n\t\t// Base case: evaluate board\n\t\tif (depth === 0) {\n            // check for quiet moves (non-captures)\n            if (isQuietMove(mostRecentMove)) {\n\t\t\t    return positionEval(playerColor) + moveEval;\n            } else {\n                const quiescence = quiescenceSearch(\n                    quiescenceDepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n                    alpha, beta\n                );\n\t\t\t\treturn quiescence;\n            }\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tlet possibleMoves = game.moves();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// if (!isQuietMove(move)) {\n\t\t\t\t// console.log(move, 'NOT QUIET. CAPTURE EVAL: ', getCaptureValue(game, move));\n\t\t\t\t// console.log(game.ascii());\n\t\t\t// }\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = minimax(depth-1, !isMaximizingPlayer, playerColor, moveEval, move, alpha, beta);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n\tfunction quiescenceSearch(\n\t\tdepth, isMaximizingPlayer, playerColor, moveEval, mostRecentMove,\n\t\talpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY\n\t) {\n\t\tconst evaluation = positionEval(playerColor) + moveEval;\n\t\t// fail-hard beta cutoff\n\t\tif (evaluation >= beta)\n\t\t{\n\t\t\t// node (move) fails high\n\t\t\treturn beta;\n\t\t}\n\n        // console.log('Quiescence search', mostRecentMove);\n\t\t// Base case: evaluate board\n\t\tif (isQuietMove(mostRecentMove) || depth === 0) {\n            // console.log('Quiescence search', mostRecentMove);\n\t\t\treturn positionEval(playerColor) + moveEval;\n\t\t}\n\n\t\t// Recursive case: search possible moves\n\t\tlet possibleMoves = game.moves();\n\t\t// console.log('presort', possibleMoves);\n\t\t// const startTime = performance.now();\n\t\tpossibleMoves = sortMoves(game, possibleMoves);\n\t\t// const endTime = performance.now();\n\t\t// sortingTime += endTime - startTime;\n\t\t// console.log('postsort', possibleMoves);\n        let bestMoveValue = isMaximizingPlayer\n\t\t\t\t\t? Number.NEGATIVE_INFINITY\n\t\t\t\t\t: Number.POSITIVE_INFINITY;\n\n\t\t// Search through all possible moves\n\t\tfor (let i = 0; i < possibleMoves.length; i++) {\n\t\t\tconst move = possibleMoves[i];\n\t\t\t// Make the move, but undo before exiting loop\n\t\t\tgame.move(move);\n\t\t\t// Recursively get the value from this move\n\t\t\tconst score = quiescenceSearch(depth-1, !isMaximizingPlayer, playerColor, moveEval, move, alpha, beta);\n\n\t\t\tif (isMaximizingPlayer) {\n\t\t\t\t// Computer's move: maximize position\n\t\t\t\tif (score > bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\talpha = Math.max(alpha, score);\n\t\t\t} else {\n\t\t\t\t// Opponent's move: minimize position\n\t\t\t\tif (score < bestMoveValue) {\n\t\t\t\t\tbestMoveValue = score;\n\t\t\t\t}\n\t\t\t\tbeta = Math.min(beta, score);\n\t\t\t}\n\t\t\tgame.undo();\n\t\t\t// Check for alpha beta pruning\n\t\t\tif (beta <= alpha) {\n\t\t\t\t// console.log('Prune', alpha, beta);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        return bestMoveValue;\n\t}\n\n\tfunction positionEval(playerColor) {\n\t\tlet position = game.fen().split(' ')[0];\n\t\tlet score = 0;\n\n\t\tObject.keys(pieceValues).forEach((key) => {\n\t\t\tscore += countOccurences(position, key.toUpperCase()) * pieceValues[key]; // white pieces\n\t\t\tscore -= countOccurences(position, key) * pieceValues[key]; // black pieces\n\t\t});\n\n\t\treturn playerColor === 'white' ? score : -score; // invert if computer is black\n\t}\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [408], function() { return __webpack_require__(470); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"408\":\"d0f93b06\",\"470\":\"c1c0833a\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/chess-ai/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t470: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkchess_ai\"] = self[\"webpackChunkchess_ai\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(408).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["MVV_LVA","p","n","b","r","q","k","bestSquares","stripped_san","move","replace","moveEval","color","includes","piece","toLowerCase","rank","file","square","slice","length","charCodeAt","getMoveValue","game","isQuietMove","value","pieceValues","attacker","victimSquare","victim","get","type","getCaptureValue","e","sortMoves","moves","moveScores","i","current_move","next_move","temp_score","temp_move","console","log","navigator","hardwareConcurrency","countOccurences","str","substr","split","onmessage","msg","bestMove","startTime","performance","now","data","depth","quiescenceDepth","posMoves","gameFEN","alpha","Chess","bestEval","Number","NEGATIVE_INFINITY","posMove","score","minimax","undo","endTime","isMaximizingPlayer","playerColor","mostRecentMove","beta","POSITIVE_INFINITY","positionEval","quiescence","quiescenceSearch","possibleMoves","bestMoveValue","Math","max","min","evaluation","position","fen","Object","keys","forEach","key","toUpperCase","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","d","definition","o","defineProperty","enumerable","f","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","call","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","push","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}